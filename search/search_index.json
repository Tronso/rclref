{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the rclref develoment site rclref is a reference implementation of a key-value store built on riak-core-lite. rclref was created as part of Google Summer of Code 2020 with the aim of exercising various APIs of riak-core-lite with documented support. Development languages and tools The code is fully written in Erlang OTP > 21. License rclref is released under Apache License, Version 2.0 Table of Cotents","title":"Welcome to the rclref develoment site"},{"location":"#welcome-to-the-rclref-develoment-site","text":"rclref is a reference implementation of a key-value store built on riak-core-lite. rclref was created as part of Google Summer of Code 2020 with the aim of exercising various APIs of riak-core-lite with documented support.","title":"Welcome to the rclref develoment site"},{"location":"#development-languages-and-tools","text":"The code is fully written in Erlang OTP > 21.","title":"Development languages and tools"},{"location":"#license","text":"rclref is released under Apache License, Version 2.0","title":"License"},{"location":"#table-of-cotents","text":"","title":"Table of Cotents"},{"location":"Sample_Usage/","text":"Usage Erlang interface Get a Key-Value with key = dog ( rclref @ 127 . 0 . 0 . 1 ) 1 > rclref_client : get ( << \"dog\" >> ). { error , not_found } Store a Key-Value with key = dog, value = cat (rclref@127.0.0.1)2> rclref_client : put ( << \"dog\" >> , << \"cat\" >> ). ok Get a Key-Value with key = dog (rclref@127.0.0.1)7> rclref_client : get ( << \"dog\" >> ). {ok,[<<\"cat\">>,<<\"cat\">>,<<\"cat\">>]} List all keys (rclref@127.0.0.1)2> rclref_client : list_keys (). {ok,[<<\"dog\">>]} Delete a Key-Value with key = dog. (Internally, this will not delete the value but leave it as a tombstone) (rclref@127.0.0.1)8> rclref_client : delete ( << \"dog\" >> ). ok Get a Key-Value with key = dog. Note that tombstones are not observable. (rclref@127.0.0.1)8> rclref_client : get ( << \"dog\" >> ). {error,not_found} HTTP interface Get a Key-Value with key = dog | = > curl -X GET http://localhost:8080/rclref/dog { \"error\" : { \"code\" : 404 , \"reason\" : \"not_found\" } } Store a Key-Value with key = dog, value = cat | = > curl -X POST http://localhost:8080/rclref/dog -d 'cat' { \"ok\" : { \"code\" : 200 } } Get a Key-Value with key = dog | = > curl -X GET http://localhost:8080/rclref/dog { \"ok\" : { \"code\" : 200 , \"values\" : [ \"cat\" , \"cat\" , \"cat\" ] } } Delete a Key-Value with key = dog. (Internally, this will not delete the value but leave it as a tombstone) | = > curl -X DELETE http://localhost:8080/rclref/dog { \"ok\" : { \"code\" : 200 } } Get a Key-Value with key = dog. Note that tombstones are not observable. | = > curl -X GET http://localhost:8080/rclref/dog { \"error\" : { \"code\" : 404 , \"reason\" : \"not_found\" } }","title":"Usage"},{"location":"Sample_Usage/#usage","text":"","title":"Usage"},{"location":"Sample_Usage/#erlang-interface","text":"Get a Key-Value with key = dog ( rclref @ 127 . 0 . 0 . 1 ) 1 > rclref_client : get ( << \"dog\" >> ). { error , not_found } Store a Key-Value with key = dog, value = cat (rclref@127.0.0.1)2> rclref_client : put ( << \"dog\" >> , << \"cat\" >> ). ok Get a Key-Value with key = dog (rclref@127.0.0.1)7> rclref_client : get ( << \"dog\" >> ). {ok,[<<\"cat\">>,<<\"cat\">>,<<\"cat\">>]} List all keys (rclref@127.0.0.1)2> rclref_client : list_keys (). {ok,[<<\"dog\">>]} Delete a Key-Value with key = dog. (Internally, this will not delete the value but leave it as a tombstone) (rclref@127.0.0.1)8> rclref_client : delete ( << \"dog\" >> ). ok Get a Key-Value with key = dog. Note that tombstones are not observable. (rclref@127.0.0.1)8> rclref_client : get ( << \"dog\" >> ). {error,not_found}","title":"Erlang interface"},{"location":"Sample_Usage/#http-interface","text":"Get a Key-Value with key = dog | = > curl -X GET http://localhost:8080/rclref/dog { \"error\" : { \"code\" : 404 , \"reason\" : \"not_found\" } } Store a Key-Value with key = dog, value = cat | = > curl -X POST http://localhost:8080/rclref/dog -d 'cat' { \"ok\" : { \"code\" : 200 } } Get a Key-Value with key = dog | = > curl -X GET http://localhost:8080/rclref/dog { \"ok\" : { \"code\" : 200 , \"values\" : [ \"cat\" , \"cat\" , \"cat\" ] } } Delete a Key-Value with key = dog. (Internally, this will not delete the value but leave it as a tombstone) | = > curl -X DELETE http://localhost:8080/rclref/dog { \"ok\" : { \"code\" : 200 } } Get a Key-Value with key = dog. Note that tombstones are not observable. | = > curl -X GET http://localhost:8080/rclref/dog { \"error\" : { \"code\" : 404 , \"reason\" : \"not_found\" } }","title":"HTTP interface"},{"location":"UserAPI/","text":"rclref_client Module rclref_client Module Summary Basic functions for manipulating rclref Description This module provides basic funcitons for reading data from and storing data into rclref, a key-value store on riak-core-lite. put(Key, Value) put(Key, Value, Options) get(Key) get(Key, Options) delete(Key) delete(Key, Options) list_keys() list_keys(Options) put(Key, Value) 1 -spec put(rclref_object:key(), rclref_object:value()) -> ok | {error, timeout} | {error, partial} | {error, term()}. This is equal to rclref_put(Key, Value, []) put(Key, Value, Options) 1 -spec put(rclref_object:key(), rclref_object:value(), [term()]) -> ok | {error, timeout} | {error, partial} | {error, term()}. store a Key-Value in N vnodes. When W vnodes respond with ok or more than N-W number of vnodes respond with an error, this function will return. If neither of these is satisified within TIMEOUT_PUT, then this function will return {error, timeout} Returns ok when W vnodes respond with ok. Returns {error, partial} when at least one of the vnodes (but not more than or equal to W vnodes) responds with ok before getting errors from more than N-W vnodes. Returns {error, [Reason]} when no vnodes respond with ok and more than N-W vnodes respond with an error. [Reason] is a list that contains error reasons of N-W+1 vnodes. Returns {error, timeout} when neither of these above are satisfied within TIMEOUT_PUT milliseconds. get(Key) 1 -spec get(rclref_object:key()) -> {ok, [rclref_object:value()]} | {error, timeout} | {error, partial} | {error, not_found} | {error, term()}. This is equal to get(Key, Value, Options) . get(Key, Options) 1 -spec get(rclref_object:key(), [term()]) -> {ok, [rclref_object:value()]} | {error, timeout} | {error, partial} | {error, not_found} | {error, term()}. get a Key-Value from N vnodes. When R number of vnodes respond with ok or more than N-R number of vnodes respond with an error, this fucntion will return. If neither of these is satisified with TIMEOUT_GET, then this function will return {error, timeout} On get, response from a vnode will be the either of {ok, RObj} , {error, not_found} , {error, Reason} Returns {ok, [Value]} when R vnodes respond with a value. [Value] is a list that contains values from R vnodes. Returns {error, partial} when at least one of the vnodes (but not more than or equal to R vnodes) responds with a value before getting errors from more than N-R vnodes. Returns {error, not_found} when no vnodes respond with a value and more than N-R vnodes respond with a error which are all not_found. Returns {error, [Reason]} when no vnodes respond with a value and more than N-R vnodes respond with a error which are not all not_found. [Reason] is a list that contains error reasons of N-R+1 vnodes. Returns {error, timeout} when neither of these above is satisified within TIMEOUT_GET milliseconds. delete(Key) 1 -spec delete(rclref_object:key()) -> ok | {error, timeout} | {error, partial} | {error, term()}. This is equal to delete(Key, []) . delete(Key, Options) 1 -spec delete(rclref_object:key(), [term()]) -> ok | {error, timeout} | {error, partial} | {error, term()}. This is equal to put(Key, undefined, Options) . Note that this will not delete the Key from the backend, however rclref_client:get(Key) will return {error, not_found} after calling this function. The reason why this is implemeted this way is explained in the [TODO] section. A Key-Value with an undefined value is called a tombstone. list_keys() 1 -spec list_keys() -> {ok, [rclref_object:key()]}. This is equal to list_keys([]) . list_keys(Options) 1 -spec list_keys([term()]) -> {ok, [rclref_object:key()]}. list all unique keys in the backend.","title":"rclref_client"},{"location":"UserAPI/#rclref_client","text":"","title":"rclref_client"},{"location":"UserAPI/#module","text":"rclref_client","title":"Module"},{"location":"UserAPI/#module-summary","text":"Basic functions for manipulating rclref","title":"Module Summary"},{"location":"UserAPI/#description","text":"This module provides basic funcitons for reading data from and storing data into rclref, a key-value store on riak-core-lite. put(Key, Value) put(Key, Value, Options) get(Key) get(Key, Options) delete(Key) delete(Key, Options) list_keys() list_keys(Options)","title":"Description"},{"location":"UserAPI/#putkey-value","text":"1 -spec put(rclref_object:key(), rclref_object:value()) -> ok | {error, timeout} | {error, partial} | {error, term()}. This is equal to rclref_put(Key, Value, [])","title":"put(Key, Value)"},{"location":"UserAPI/#putkey-value-options","text":"1 -spec put(rclref_object:key(), rclref_object:value(), [term()]) -> ok | {error, timeout} | {error, partial} | {error, term()}. store a Key-Value in N vnodes. When W vnodes respond with ok or more than N-W number of vnodes respond with an error, this function will return. If neither of these is satisified within TIMEOUT_PUT, then this function will return {error, timeout} Returns ok when W vnodes respond with ok. Returns {error, partial} when at least one of the vnodes (but not more than or equal to W vnodes) responds with ok before getting errors from more than N-W vnodes. Returns {error, [Reason]} when no vnodes respond with ok and more than N-W vnodes respond with an error. [Reason] is a list that contains error reasons of N-W+1 vnodes. Returns {error, timeout} when neither of these above are satisfied within TIMEOUT_PUT milliseconds.","title":"put(Key, Value, Options)"},{"location":"UserAPI/#getkey","text":"1 -spec get(rclref_object:key()) -> {ok, [rclref_object:value()]} | {error, timeout} | {error, partial} | {error, not_found} | {error, term()}. This is equal to get(Key, Value, Options) .","title":"get(Key)"},{"location":"UserAPI/#getkey-options","text":"1 -spec get(rclref_object:key(), [term()]) -> {ok, [rclref_object:value()]} | {error, timeout} | {error, partial} | {error, not_found} | {error, term()}. get a Key-Value from N vnodes. When R number of vnodes respond with ok or more than N-R number of vnodes respond with an error, this fucntion will return. If neither of these is satisified with TIMEOUT_GET, then this function will return {error, timeout} On get, response from a vnode will be the either of {ok, RObj} , {error, not_found} , {error, Reason} Returns {ok, [Value]} when R vnodes respond with a value. [Value] is a list that contains values from R vnodes. Returns {error, partial} when at least one of the vnodes (but not more than or equal to R vnodes) responds with a value before getting errors from more than N-R vnodes. Returns {error, not_found} when no vnodes respond with a value and more than N-R vnodes respond with a error which are all not_found. Returns {error, [Reason]} when no vnodes respond with a value and more than N-R vnodes respond with a error which are not all not_found. [Reason] is a list that contains error reasons of N-R+1 vnodes. Returns {error, timeout} when neither of these above is satisified within TIMEOUT_GET milliseconds.","title":"get(Key, Options)"},{"location":"UserAPI/#deletekey","text":"1 -spec delete(rclref_object:key()) -> ok | {error, timeout} | {error, partial} | {error, term()}. This is equal to delete(Key, []) .","title":"delete(Key)"},{"location":"UserAPI/#deletekey-options","text":"1 -spec delete(rclref_object:key(), [term()]) -> ok | {error, timeout} | {error, partial} | {error, term()}. This is equal to put(Key, undefined, Options) . Note that this will not delete the Key from the backend, however rclref_client:get(Key) will return {error, not_found} after calling this function. The reason why this is implemeted this way is explained in the [TODO] section. A Key-Value with an undefined value is called a tombstone.","title":"delete(Key, Options)"},{"location":"UserAPI/#list_keys","text":"1 -spec list_keys() -> {ok, [rclref_object:key()]}. This is equal to list_keys([]) .","title":"list_keys()"},{"location":"UserAPI/#list_keysoptions","text":"1 -spec list_keys([term()]) -> {ok, [rclref_object:key()]}. list all unique keys in the backend.","title":"list_keys(Options)"},{"location":"put_get_delete/","text":"put, get, delete This page shows provides an overview of how put, get and delete are implemented in rclref. How are put, get and delete implemented? Put, get and delete have almost the same code flow. The code flow of rclref_client:get(Key) is shown in the following diagram. The usage of the UserAPI (rclref_client.erl) is described in TODO section. When a user commands rclref_client:get(Key) , it will start a supervisor which manages a get coodinator in simle one for one strategy. Then the coordinator will ask the vnodes for data and send it back to the API module once it has collected a certain number of responses. Lets look at how each part of them are implemented in more detail. UserAPI The following is a snippet from rclref_client.erl . -spec get(rclref_object:key(), [term()]) -> {ok, [rclref_object:value()]} | {error, timeout} | {error, partial} | {error, not_found} | {error, [term()]}. get(Key, Options) when is_list(Options) -> case rclref:get(Key, Options) of {ok, RObjs} -> {ok, [rclref_object:value(RObj) || RObj <- RObjs]}; {error, timeout} -> {error, timeout}; {{ok, []}, {error, VnodeErrors}} -> % If all the errors are not_found, return not_found. Otherwise return all errors. Reasons = [rclref_object:error_reason(VnodeError) || VnodeError <- VnodeErrors], case lists:all(fun (Reason) -> Reason =:= not_found end, Reasons) of true -> {error, not_found}; _ -> {error, Reasons} end; {{ok, _RObjs}, {error, _VnodeErrors}} -> {error, partial} end. API Supervisor Coordinator A coordnator is a process that commnunicate with the vnodes. It is implemented using gen_statem . When a request is issued from the user, it will generate a hash to determin which vnodes to send the request to and send it to them. Usually, the coordinator will send the request to multiple vnodes. Vnodes The main feature of riak_core is to distribute client requests to processes in the nodes in the cluster. These processes are often referred to as virtual nodes (vnodes). The number of vnodes in a cluster is dependent on the size of the ring of that cluster. A ring is divided into a fixed number of partitions and each vnode is responsible for one of them. A hash will be calculated from a client\u2019s request denoting which partition of the ring (thus, vnode) is responsible for handling the request. This is called consistent hashing. With consistent hashing, the following can be achieved. Even distribution of key workload between vnodes. Smooth adaption to dynamic changes in the cluster by replication of data. A detailed explanation of consistent hashing is provided here . In rclref, a vnode does a lot of things. handle put, get, delete request handle handoff request handle coverage request This page will explain how put, get and delete are implemented in rclref.","title":"put, get, delete"},{"location":"put_get_delete/#put-get-delete","text":"This page shows provides an overview of how put, get and delete are implemented in rclref.","title":"put, get, delete"},{"location":"put_get_delete/#how-are-put-get-and-delete-implemented","text":"Put, get and delete have almost the same code flow. The code flow of rclref_client:get(Key) is shown in the following diagram. The usage of the UserAPI (rclref_client.erl) is described in TODO section. When a user commands rclref_client:get(Key) , it will start a supervisor which manages a get coodinator in simle one for one strategy. Then the coordinator will ask the vnodes for data and send it back to the API module once it has collected a certain number of responses. Lets look at how each part of them are implemented in more detail.","title":"How are put, get and delete implemented?"},{"location":"put_get_delete/#userapi","text":"The following is a snippet from rclref_client.erl . -spec get(rclref_object:key(), [term()]) -> {ok, [rclref_object:value()]} | {error, timeout} | {error, partial} | {error, not_found} | {error, [term()]}. get(Key, Options) when is_list(Options) -> case rclref:get(Key, Options) of {ok, RObjs} -> {ok, [rclref_object:value(RObj) || RObj <- RObjs]}; {error, timeout} -> {error, timeout}; {{ok, []}, {error, VnodeErrors}} -> % If all the errors are not_found, return not_found. Otherwise return all errors. Reasons = [rclref_object:error_reason(VnodeError) || VnodeError <- VnodeErrors], case lists:all(fun (Reason) -> Reason =:= not_found end, Reasons) of true -> {error, not_found}; _ -> {error, Reasons} end; {{ok, _RObjs}, {error, _VnodeErrors}} -> {error, partial} end.","title":"UserAPI"},{"location":"put_get_delete/#api","text":"","title":"API"},{"location":"put_get_delete/#supervisor","text":"","title":"Supervisor"},{"location":"put_get_delete/#coordinator","text":"A coordnator is a process that commnunicate with the vnodes. It is implemented using gen_statem . When a request is issued from the user, it will generate a hash to determin which vnodes to send the request to and send it to them. Usually, the coordinator will send the request to multiple vnodes.","title":"Coordinator"},{"location":"put_get_delete/#vnodes","text":"The main feature of riak_core is to distribute client requests to processes in the nodes in the cluster. These processes are often referred to as virtual nodes (vnodes). The number of vnodes in a cluster is dependent on the size of the ring of that cluster. A ring is divided into a fixed number of partitions and each vnode is responsible for one of them. A hash will be calculated from a client\u2019s request denoting which partition of the ring (thus, vnode) is responsible for handling the request. This is called consistent hashing. With consistent hashing, the following can be achieved. Even distribution of key workload between vnodes. Smooth adaption to dynamic changes in the cluster by replication of data. A detailed explanation of consistent hashing is provided here . In rclref, a vnode does a lot of things. handle put, get, delete request handle handoff request handle coverage request This page will explain how put, get and delete are implemented in rclref.","title":"Vnodes"},{"location":"test/","text":"How to test distributed application in Erlang? In rclref, Common Test (CT) is used for integrated testing. This post explains how to use CT for distributed applications assuming that the reader already knows how to use CT in a single node environment. The issue in testing distributed application in Erlang often relies on how to spawn multiple Erlang nodes from CT and how to manage their logs. The Goal of this post is to be able to test distirbuted Erlang application using rebar3 and understand how to organize the logs of several distributed nodes. The following is a snippet from client_SUITE.erl in rclref repository. init_per_suite ( Config ) -> application : ensure_all_started ( rclref ), Names = [ node1 ], Ports = [ 30400 ], Nodes = node_utils : set_up_nodes ( Names , Ports , [{ module , ? MODULE }]), [{ module , ? MODULE }, { names , Names }, { nodes , Nodes }, { ports , Ports } | Config ]. end_per_suite ( Config ) -> Nodes = ? config ( nodes , Config ), node_utils : kill_nodes ( Nodes ), Config . put_get_delete_test ( Config ) -> [ Node ] = ? config ( nodes , Config ), Keys = [ \"key--\" ++ integer_to_list ( Num ) || Num <- lists : seq ( 1 , 20 )], Values = [ \"value--\" ++ integer_to_list ( Num ) || Num <- lists : seq ( 1 , 20 )], % check not_found lists : foreach ( fun ( Key ) -> { error , not_found } = rpc : call ( Node , rclref_client , get , [ Key ]) end , Keys ), % put values lists : foreach ( fun ({ Key , Value }) -> ok = rpc : call ( Node , rclref_client , put , [ Key , Value ]) end , lists : zip ( Keys , Values )), % confirm values lists : foreach ( fun ({ Key , Value }) -> { ok , GotValues } = rpc : call ( Node , rclref_client , get , [ Key ]), true = lists : all ( fun ( GotValue ) -> Value =:= GotValue end , GotValues ) end , lists : zip ( Keys , Values )), % delete values lists : foreach ( fun ( Key ) -> ok = rpc : call ( Node , rclref_client , delete , [ Key ]) end , Keys ), % check not_found lists : foreach ( fun ( Key ) -> { error , not_found } = rpc : call ( Node , rclref_client , get , [ Key ]) end , Keys ), ok . The init_per_suite/1 will start an applicaiotn with nodename \"node1\" on port 30400 by calling node_utils:set_upnodes(Names, Ports, [{module, ?MODULE}]) . Internally, the node_util module basically spawns a slave node with ct_slave:start/2 and configures environmental variales. CT will automatically call put_get_delete_test/1 after init_per_suite/1 is called. put_get_delete_test/1 is a basic test storing and deleteing 20 key-values to the slave node that has just been staretd by init_per_suite/1 . Note that in order to access the remote node, remote procedure call should be used. For example, putting a key-value in the slave node is done by ok = rpc:call(Node, rclref_client, put, [Key, Value]) . Now let's see the node_utls module in more detail. - spec set_up_nodes ([ atom ()], [ non_neg_integer ()], [ tuple ()]) -> [ node ()]. set_up_nodes ( Names , Ports , Config ) -> NodesWithStatus = node_utils : pmap ( fun ({ Name , Port }) -> node_utils : start_node ( Name , Port , Config ) end , lists : zip ( Names , Ports )), Nodes = [ Node || { connect , Node } <- NodesWithStatus ], ok = riak_utils : wait_until_ring_converged ( Nodes ), Nodes . As shown in the snippet above, a node is spawned by node_utls:start_node(Name, Port, Config) . The function node_utils:pmap is an asynchronous map fuction which is used to start multiple slave nodes asynchronously. - spec start_node ( atom (), non_neg_integer (), [ tuple ()]) -> { connect , node ()} | { ready , node ()}. start_node ( Name , Port , Config ) -> ct : log ( \"Starting node ~p \" , [ Name ]), CodePath = lists : filter ( fun filelib : is_dir / 1 , code : get_path ()), { ok , Cwd } = file : get_cwd (), % RclrefFolder is .../rclref/_build/test _ RclrefFolder = filename : dirname ( filename : dirname ( Cwd )), NodeConfig = [{ init_timeout , 3000 }, { startup_timeout , 3000 }, { monitor_master , true }, { startup_functions , [{ code , set_path , [ CodePath ]}]}], case ct_slave : start ( Name , NodeConfig ) of { ok , Node } -> % Load application to allow configuring the environment before starting ok = rpc : call ( Node , application , load , [ riak_core ]), ok = rpc : call ( Node , application , load , [ rclref ]), % Get remote working dir of node % NodeWorkingDir is .../rclref/_build/test/logs/ct_run.test@127.0.0.1.2020-00-00_00.00.00 { ok , NodeWorkingDir } = rpc : call ( Node , file , get_cwd , []), SuiteName = proplists : get_value ( module , Config , '' ), % Data Dirs ok = rpc : call ( Node , application , set_env , [ riak_core , ring_state_dir , filename : join ([ NodeWorkingDir , \"suites\" , SuiteName , Node , \"data/ring\" ])]), ok = rpc : call ( Node , application , set_env , [ riak_core , platform_data_dir , filename : join ([ NodeWorkingDir , \"suites\" , SuiteName , Node , \"data\" ])]), ok = rpc : call ( Node , application , set_env , [ riak_core , schema_dirs , filename : join ([ NodeWorkingDir , \"suites\" , SuiteName , Node , \"data\" ])]), % Set ports ok = rpc : call ( Node , application , set_env , [ riak_core , handoff_port , Port ]), ok = rpc : call ( Node , application , set_env , [ rclref , http_port , Port + 1 ]), % Logging Configuration LogRoot = filename : join ([ NodeWorkingDir , \"suites\" , SuiteName , Node , \"logs\" ]), ok = rpc : call ( Node , application , set_env , [ rclref , logger , log_config ( LogRoot )]), rpc : call ( Node , logger , set_primary_config , [ level , all ]), rpc : call ( Node , logger , add_handlers , [ rclref ]), % redirect slave logs to ct_master logs ok = rpc : call ( Node , application , set_env , [ rclref , ct_master , node ()]), ConfLog = #{ level => debug , formatter => { logger_formatter , #{ single_line => true , max_size => 2048 }}, config => #{ type => standard_io }}, _ = rpc : call ( Node , logger , add_handler , [ rclref_redirect_ct , ct_redirect_handler , ConfLog ]), % Configuration ok = rpc : call ( Node , application , set_env , [ riak_core , ring_creation_size , 8 ]), { ok , _} = rpc : call ( Node , application , ensure_all_started , [ riak_core ]), { ok , _} = rpc : call ( Node , application , ensure_all_started , [ rclref ]), ct : pal ( \"Node ~p stated with (handoff) port ~p \" , [ Node , Port ]), { connect , Node }; { error , already_started , Node } -> ct : log ( \"Node ~p already started, reusing node\" , [ Node ]), { ready , Node }; { error , Reason , Node } -> ct : pal ( \"Error starting node ~p , reason ~p , will retry\" , [ Node , Reason ]), ct_slave : stop ( Name ), time_utils : wait_until_offline ( Node ), start_node ( Name , Port , Config ) end . start_node/3 is the main fuction for starting up the nodes. As soon as the slave node has started by using ct_slave:start/2 , it is loading the applicaiton by rpc calls, such as ok = rpc:call(Node, application, load, [riak_core]) and ok = rpc:call(Node, application, load, [rclref]) . Once these are called, you can update the environment vairbales from the default values with rpc:call(Node, appcliation, set_env, [...]) . In rclref, setting environmental values such as where to store the riak_core related data and which port is used for handoff and http communication are managed this way. % Logging Configuration LogRoot = filename : join ([ NodeWorkingDir , \"suites\" , SuiteName , Node , \"logs\" ]), ok = rpc : call ( Node , application , set_env , [ rclref , logger , log_config ( LogRoot )]), The snippet above is for setting up the logging environment. LogRoot is the log directory for each node. In rclref, nodes are not reused for each test suite for saftey reasons so logs are seperated from each suite. For test suite that uses two nodes, the log directory looks like the following. | -- handoff_SUITE | | -- node1@localhost | | | -- data | | | ` -- ring | | | | -- riak_core_ring.default.20200817183651 | | | ` -- riak_core_ring.default.20200817183720 | | ` -- logs | | | -- debug.log | | | -- error.log | | | -- info.log | | | -- notice.log | | ` -- warning.log | ` -- node2@localhost | | -- data | | ` -- ring | | | -- riak_core_ring.default.20200817183650 | | | -- riak_core_ring.default.20200817183710 | | ` -- riak_core_ring.default.20200817183720 | ` -- logs | | -- debug.log | | -- error.log | | -- info.log | | -- notice.log | ` -- warning.log","title":"How to test distributed application in Erlang?"},{"location":"test/#how-to-test-distributed-application-in-erlang","text":"In rclref, Common Test (CT) is used for integrated testing. This post explains how to use CT for distributed applications assuming that the reader already knows how to use CT in a single node environment. The issue in testing distributed application in Erlang often relies on how to spawn multiple Erlang nodes from CT and how to manage their logs. The Goal of this post is to be able to test distirbuted Erlang application using rebar3 and understand how to organize the logs of several distributed nodes. The following is a snippet from client_SUITE.erl in rclref repository. init_per_suite ( Config ) -> application : ensure_all_started ( rclref ), Names = [ node1 ], Ports = [ 30400 ], Nodes = node_utils : set_up_nodes ( Names , Ports , [{ module , ? MODULE }]), [{ module , ? MODULE }, { names , Names }, { nodes , Nodes }, { ports , Ports } | Config ]. end_per_suite ( Config ) -> Nodes = ? config ( nodes , Config ), node_utils : kill_nodes ( Nodes ), Config . put_get_delete_test ( Config ) -> [ Node ] = ? config ( nodes , Config ), Keys = [ \"key--\" ++ integer_to_list ( Num ) || Num <- lists : seq ( 1 , 20 )], Values = [ \"value--\" ++ integer_to_list ( Num ) || Num <- lists : seq ( 1 , 20 )], % check not_found lists : foreach ( fun ( Key ) -> { error , not_found } = rpc : call ( Node , rclref_client , get , [ Key ]) end , Keys ), % put values lists : foreach ( fun ({ Key , Value }) -> ok = rpc : call ( Node , rclref_client , put , [ Key , Value ]) end , lists : zip ( Keys , Values )), % confirm values lists : foreach ( fun ({ Key , Value }) -> { ok , GotValues } = rpc : call ( Node , rclref_client , get , [ Key ]), true = lists : all ( fun ( GotValue ) -> Value =:= GotValue end , GotValues ) end , lists : zip ( Keys , Values )), % delete values lists : foreach ( fun ( Key ) -> ok = rpc : call ( Node , rclref_client , delete , [ Key ]) end , Keys ), % check not_found lists : foreach ( fun ( Key ) -> { error , not_found } = rpc : call ( Node , rclref_client , get , [ Key ]) end , Keys ), ok . The init_per_suite/1 will start an applicaiotn with nodename \"node1\" on port 30400 by calling node_utils:set_upnodes(Names, Ports, [{module, ?MODULE}]) . Internally, the node_util module basically spawns a slave node with ct_slave:start/2 and configures environmental variales. CT will automatically call put_get_delete_test/1 after init_per_suite/1 is called. put_get_delete_test/1 is a basic test storing and deleteing 20 key-values to the slave node that has just been staretd by init_per_suite/1 . Note that in order to access the remote node, remote procedure call should be used. For example, putting a key-value in the slave node is done by ok = rpc:call(Node, rclref_client, put, [Key, Value]) . Now let's see the node_utls module in more detail. - spec set_up_nodes ([ atom ()], [ non_neg_integer ()], [ tuple ()]) -> [ node ()]. set_up_nodes ( Names , Ports , Config ) -> NodesWithStatus = node_utils : pmap ( fun ({ Name , Port }) -> node_utils : start_node ( Name , Port , Config ) end , lists : zip ( Names , Ports )), Nodes = [ Node || { connect , Node } <- NodesWithStatus ], ok = riak_utils : wait_until_ring_converged ( Nodes ), Nodes . As shown in the snippet above, a node is spawned by node_utls:start_node(Name, Port, Config) . The function node_utils:pmap is an asynchronous map fuction which is used to start multiple slave nodes asynchronously. - spec start_node ( atom (), non_neg_integer (), [ tuple ()]) -> { connect , node ()} | { ready , node ()}. start_node ( Name , Port , Config ) -> ct : log ( \"Starting node ~p \" , [ Name ]), CodePath = lists : filter ( fun filelib : is_dir / 1 , code : get_path ()), { ok , Cwd } = file : get_cwd (), % RclrefFolder is .../rclref/_build/test _ RclrefFolder = filename : dirname ( filename : dirname ( Cwd )), NodeConfig = [{ init_timeout , 3000 }, { startup_timeout , 3000 }, { monitor_master , true }, { startup_functions , [{ code , set_path , [ CodePath ]}]}], case ct_slave : start ( Name , NodeConfig ) of { ok , Node } -> % Load application to allow configuring the environment before starting ok = rpc : call ( Node , application , load , [ riak_core ]), ok = rpc : call ( Node , application , load , [ rclref ]), % Get remote working dir of node % NodeWorkingDir is .../rclref/_build/test/logs/ct_run.test@127.0.0.1.2020-00-00_00.00.00 { ok , NodeWorkingDir } = rpc : call ( Node , file , get_cwd , []), SuiteName = proplists : get_value ( module , Config , '' ), % Data Dirs ok = rpc : call ( Node , application , set_env , [ riak_core , ring_state_dir , filename : join ([ NodeWorkingDir , \"suites\" , SuiteName , Node , \"data/ring\" ])]), ok = rpc : call ( Node , application , set_env , [ riak_core , platform_data_dir , filename : join ([ NodeWorkingDir , \"suites\" , SuiteName , Node , \"data\" ])]), ok = rpc : call ( Node , application , set_env , [ riak_core , schema_dirs , filename : join ([ NodeWorkingDir , \"suites\" , SuiteName , Node , \"data\" ])]), % Set ports ok = rpc : call ( Node , application , set_env , [ riak_core , handoff_port , Port ]), ok = rpc : call ( Node , application , set_env , [ rclref , http_port , Port + 1 ]), % Logging Configuration LogRoot = filename : join ([ NodeWorkingDir , \"suites\" , SuiteName , Node , \"logs\" ]), ok = rpc : call ( Node , application , set_env , [ rclref , logger , log_config ( LogRoot )]), rpc : call ( Node , logger , set_primary_config , [ level , all ]), rpc : call ( Node , logger , add_handlers , [ rclref ]), % redirect slave logs to ct_master logs ok = rpc : call ( Node , application , set_env , [ rclref , ct_master , node ()]), ConfLog = #{ level => debug , formatter => { logger_formatter , #{ single_line => true , max_size => 2048 }}, config => #{ type => standard_io }}, _ = rpc : call ( Node , logger , add_handler , [ rclref_redirect_ct , ct_redirect_handler , ConfLog ]), % Configuration ok = rpc : call ( Node , application , set_env , [ riak_core , ring_creation_size , 8 ]), { ok , _} = rpc : call ( Node , application , ensure_all_started , [ riak_core ]), { ok , _} = rpc : call ( Node , application , ensure_all_started , [ rclref ]), ct : pal ( \"Node ~p stated with (handoff) port ~p \" , [ Node , Port ]), { connect , Node }; { error , already_started , Node } -> ct : log ( \"Node ~p already started, reusing node\" , [ Node ]), { ready , Node }; { error , Reason , Node } -> ct : pal ( \"Error starting node ~p , reason ~p , will retry\" , [ Node , Reason ]), ct_slave : stop ( Name ), time_utils : wait_until_offline ( Node ), start_node ( Name , Port , Config ) end . start_node/3 is the main fuction for starting up the nodes. As soon as the slave node has started by using ct_slave:start/2 , it is loading the applicaiton by rpc calls, such as ok = rpc:call(Node, application, load, [riak_core]) and ok = rpc:call(Node, application, load, [rclref]) . Once these are called, you can update the environment vairbales from the default values with rpc:call(Node, appcliation, set_env, [...]) . In rclref, setting environmental values such as where to store the riak_core related data and which port is used for handoff and http communication are managed this way. % Logging Configuration LogRoot = filename : join ([ NodeWorkingDir , \"suites\" , SuiteName , Node , \"logs\" ]), ok = rpc : call ( Node , application , set_env , [ rclref , logger , log_config ( LogRoot )]), The snippet above is for setting up the logging environment. LogRoot is the log directory for each node. In rclref, nodes are not reused for each test suite for saftey reasons so logs are seperated from each suite. For test suite that uses two nodes, the log directory looks like the following. | -- handoff_SUITE | | -- node1@localhost | | | -- data | | | ` -- ring | | | | -- riak_core_ring.default.20200817183651 | | | ` -- riak_core_ring.default.20200817183720 | | ` -- logs | | | -- debug.log | | | -- error.log | | | -- info.log | | | -- notice.log | | ` -- warning.log | ` -- node2@localhost | | -- data | | ` -- ring | | | -- riak_core_ring.default.20200817183650 | | | -- riak_core_ring.default.20200817183710 | | ` -- riak_core_ring.default.20200817183720 | ` -- logs | | -- debug.log | | -- error.log | | -- info.log | | -- notice.log | ` -- warning.log","title":"How to test distributed application in Erlang?"}]}